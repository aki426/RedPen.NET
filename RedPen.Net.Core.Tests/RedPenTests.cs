//   Copyright (c) 2024 KANEDA Akihiro <taoist.aki@gmail.com>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using FluentAssertions;
using RedPen.Net.Core.Config;
using RedPen.Net.Core.Errors;
using RedPen.Net.Core.Globals;
using RedPen.Net.Core.Model;
using RedPen.Net.Core.Parser;
using RedPen.Net.Core.Tokenizer;
using RedPen.Net.Core.Validators;
using Xunit;
using Xunit.Abstractions;

namespace RedPen.Net.Core.Tests
{
    public class RedPenTests
    {
        private ITestOutputHelper output;

        public RedPenTests(ITestOutputHelper output)
        {
            this.output = output;
        }

        private static string sampleDocument = @"
RedPen.NETは、(OSSのJAVAアプリケーションRedPenのC#再実装版です。
基本的な開発動機として、日本語の文章校正を行うためのC#アプリケションからRedPenを利用することを目的としています。
最終的には本家RedPenの全機能をサポートすることを目標としていますが、次の独自方針を持っています。
";

        [Fact]
        public void BasicTest()
        {
            // JsonファイルからConfigurationを読み込む。
            var confFilePath = Path.Combine(Directory.GetCurrentDirectory(), "Config", "DATA", "SampleConf.json");

            // TODO: オリジナルのValidatorを追加したい場合、ConfigurationLoaderに与える
            // ValidationNameとValidatorConfigurationのTypeのDictionaryにオリジナルValidatorの情報を追加すればよい。

            // ConfigurationLoaderは引数で定義されたValidatorConfigurationのみ読み込みを許可される。
            // ライブラリ実装済みのValidatorConfiguration定義を与える。
            var jsonLoader = new ConfigurationLoader(DefaultValidationDefinition.ValidationNameToValidatorConfigurationTypeMap);
            Configuration configuration = jsonLoader.Load(File.ReadAllText(confFilePath));

            configuration.DocumentLang.Should().Be("ja-JP");
            configuration.DocumentCultureInfo.Should().Be(new System.Globalization.CultureInfo("ja-JP"));
            configuration.Variant.Should().Be("zenkaku");
            configuration.ValidatorConfigurations.Count.Should().Be(26);

            // ValidatorConfiguration -> Validatorの生成
            ValidatorFactory validatorFactory = new ValidatorFactory();
            // このリストに対してValidatorを挿入すれば、オリジナルのValidationを実行できる。
            List<Validator> validators = new List<Validator>();

            foreach (var validatorConfig in configuration.ValidatorConfigurations)
            {
                DefaultValidationDefinition.ValidationNames.Contains(validatorConfig.Name).Should().BeTrue();
                validatorConfig.Level.Should().Be(ValidationLevel.ERROR);
                output.WriteLine(validatorConfig.ToString());

                // OFFの場合はValidatorを生成しない。これはアプリケーションの都合なのでValidatorFactoryでは判定しない。
                if (validatorConfig.Level != ValidationLevel.OFF)
                {
                    // NOTE: 生成時にはDocumentLangに対して対応するValidatorかどうかの判定は行われ、対応していない場合は例外が発生する。
                    Validator validator = validatorFactory.GetValidator(configuration.DocumentCultureInfo, configuration.SymbolTable, validatorConfig);
                    if (validator != null)
                    {
                        validators.Add(validator);
                    }
                    else
                    {
                        Assert.True(false, "Validator not found.");
                    }
                }
            }

            // NOTE: 一旦すべてのConfigurationからValidadtorが生成されるパターンを想定する。
            validators.Count.Should().Be(configuration.ValidatorConfigurations.Count);

            // サンプルドキュメントに対してParse & Tokenizeを行う。
            Document document = null;
            try
            {
                // NOTE: ドキュメントのフォーマットは入力ファイルの拡張子などで判別するのが一般的だが、
                // それはCoreライブラリの領域ではないのでParserの指定は応用アプリケーションで行い、選択はCoreで行う。
                document = new PlainTextParser().Parse(
                    sampleDocument,
                    new SentenceExtractor(configuration.SymbolTable),
                    RedPenTokenizerFactory.CreateTokenizer(configuration.DocumentCultureInfo));
            }
            catch (Exception e)
            {
                Assert.True(false, "Exception not expected.");
            }

            // Validate
            List<ValidationError> errors = new List<ValidationError>();
            // To Document
            foreach (Validator validator in validators.Where(v => v is IDocumentValidatable))
            {
                errors.AddRange((validator as IDocumentValidatable).Validate(document));
            }
            // To Sentences
            foreach (ISentenceValidatable validator in
                validators.Where(v => v is ISentenceValidatable).Select(v => v as ISentenceValidatable))
            {
                foreach (var sentence in document.GetAllSentences().Where(s => s.Content != ""))
                {
                    errors.AddRange(validator.Validate(sentence));
                }
            }

            // 全エラーの可視化とエラー内容の検証。
            if (errors.Any())
            {
                var manager = ErrorMessageManager.GetInstance();

                output.WriteLine("");
                output.WriteLine("★Errors:");
                foreach (var error in errors)
                {
                    output.WriteLine(error.ToString());
                    output.WriteLine(manager.GetErrorMessage(error, configuration.DocumentCultureInfo));
                }
            }
        }
    }
}
