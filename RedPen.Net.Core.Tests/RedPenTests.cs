using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using FluentAssertions;
using RedPen.Net.Core.Config;
using RedPen.Net.Core.Errors;
using RedPen.Net.Core.Model;
using RedPen.Net.Core.Parser;
using RedPen.Net.Core.Tokenizer;
using RedPen.Net.Core.Validators;
using Xunit;
using Xunit.Abstractions;
using static System.Net.Mime.MediaTypeNames;

namespace RedPen.Net.Core.Tests
{
    public class RedPenTests
    {
        private ITestOutputHelper output;

        public RedPenTests(ITestOutputHelper output)
        {
            this.output = output;
        }

        private static List<string> validationNames = new List<string>()
        {
            "CommaCount",
            "Contraction",
            "DoubledConjunctiveParticleGa",
            "DoubledJoshi",
            "DoubledWord",
            "DoubleNegative",
            "DuplicatedSection",
            "EmptySection",
            "FrequentSentenceStart",
            "GappedSection",
            "HankakuKana",
            "HeaderLength",
            "Hyphenation",
            "InvalidExpression",
            "InvalidSymbol",
            "InvalidWord",
            "JapaneseAbusage",
            "JapaneseAmbiguousNounConjunction",
            "JapaneseAnchorExpression",
            "JapaneseDoubledConjunction",
            "JapaneseDroppingRa",
            "JapaneseWordVariation",
            "JapaneseFiller",
            "JapaneseOfficialDocumentsKanjiUsage",
            "JapaneseGeneralNovelStyle",
            "JapaneseInappropriateWord",
            "JapaneseInvalidSa",
            "JapaneseJoyoKanji",
            "JapaneseMixedZenHanAlphabet",
            "JapaneseNumberExpression",
            "JapanesePreferTariTari",
            "JapaneseRedundantExpression",
            "JapaneseStyle",
            "JapaneseSymbolWithSpace",
            "JapaneseUnnaturalAlphabet",
            "JapaneseWeakExpression",
            "JavaScript",
            "KatakanaEndHyphen",
            "KatakanaSpellCheck",
            "ListLevel",
            "LongKanjiChain",
            "NumberFormat",
            "Okurigana",
            "ParagraphCount",
            "ParagraphStartWith",
            "InvalidParenthesis",
            "SectionWordCount",
            "SectionLevel",
            "SentenceLength",
            "SpaceBeginningOfSentence",
            "SpaceWithAlphabeticalExpression",
            "Spelling",
            "StartWithCapitalLetter",
            "SuccessiveSentence",
            "SuccessiveWord",
            "SuggestExpression",
            "SymbolWithSpace",
            "Taigendome",
            "UnexpandedAcronym",
            "VoidSection",
            "WeakExpression",
            "WordFrequency",
            "SentenceWordCount",
            "SuggestGrammarRule"
        };

        private static string sampleDocument = @"
RedPen.NETは、(OSSのJAVAアプリケーションRedPenのC#再実装版です。
基本的な開発動機として、日本語の文章校正を行うためのC#アプリケションからRedPenを利用することを目的としています。
最終的には本家RedPenの全機能をサポートすることを目標としていますが、次の独自方針を持っています。
";

        [Fact]
        public void BasicTest()
        {
            // JsonファイルからConfigurationを読み込む。
            var confFilePath = Path.Combine(Directory.GetCurrentDirectory(), "Config", "DATA", "SampleConf.json");
            // TODO: オリジナルのValidatorを追加したい場合、
            // ConfigurationLoaderはValidationTypeに定義されたものしかLoadしないのでそこがネックとなる。
            // TODO: ValidationTypeをEnumで定義するのをやめて、record型などにして、
            // ConfigurationLoader.Loadへ許容すべきValidatorConfigurationsリストとして与える？
            // ValidatorFactoryに対しても同様。

            var jsonLoader = new ConfigurationLoader();
            Configuration configuration = jsonLoader.Load(File.ReadAllText(confFilePath));

            configuration.Lang.Should().Be("ja-JP");
            configuration.CultureInfo.Should().Be(new System.Globalization.CultureInfo("ja-JP"));
            configuration.Variant.Should().Be("zenkaku");
            configuration.ValidatorConfigurations.Count.Should().Be(26);

            // ValidatorConfiguration -> Validatorの生成
            ValidatorFactory validatorFactory = ValidatorFactory.GetInstance();
            // このリストに対してValidatorを挿入すれば、オリジナルのValidationを実行できる。
            List<Validator> validators = new List<Validator>();

            foreach (var validatorConfig in configuration.ValidatorConfigurations)
            {
                validationNames.Contains(validatorConfig.Name).Should().BeTrue();
                validatorConfig.Level.Should().Be(ValidationLevel.ERROR);
                output.WriteLine(validatorConfig.ToString());

                // OFFの場合はValidatorを生成しない。これはアプリケーションの都合なのでValidatorFactoryでは判定しない。
                if (validatorConfig.Level != ValidationLevel.OFF)
                {
                    // NOTE: 生成時にはDocumentLangに対して対応するValidatorかどうかの判定は行われ、対応していない場合は例外が発生する。
                    validators.Add(validatorFactory.GetValidator(configuration.CultureInfo, configuration.SymbolTable, validatorConfig));
                }
            }

            // NOTE: 一旦すべてのConfigurationからValidadtorが生成されるパターンを想定する。
            validators.Count.Should().Be(configuration.ValidatorConfigurations.Count);

            // サンプルドキュメントに対してParse & Tokenizeを行う。
            Document document = null;
            try
            {
                // NOTE: ドキュメントのフォーマットは入力ファイルの拡張子などで判別するのが一般的だが、
                // それはCoreライブラリの領域ではないのでParserの指定は応用アプリケーションで行い、選択はCoreで行う。
                document = new PlainTextParser().Parse(
                    sampleDocument,
                    new SentenceExtractor(configuration.SymbolTable),
                    RedPenTokenizerFactory.CreateTokenizer(configuration.CultureInfo));
            }
            catch (Exception e)
            {
                Assert.True(false, "Exception not expected.");
            }

            // Validate
            List<ValidationError> errors = new List<ValidationError>();
            // To Document
            foreach (Validator validator in validators.Where(v => v is IDocumentValidatable))
            {
                errors.AddRange((validator as IDocumentValidatable).Validate(document));
            }
            // To Sentences
            foreach (ISentenceValidatable validator in
                validators.Where(v => v is ISentenceValidatable).Select(v => v as ISentenceValidatable))
            {
                foreach (var sentence in document.GetAllSentences().Where(s => s.Content != ""))
                {
                    errors.AddRange(validator.Validate(sentence));
                }
            }

            // 全エラーの可視化とエラー内容の検証。
            if (errors.Any())
            {
                var manager = ErrorMessageManager.GetInstance();

                output.WriteLine("");
                output.WriteLine("★Errors:");
                foreach (var error in errors)
                {
                    output.WriteLine(error.ToString());
                    output.WriteLine(manager.GetErrorMessage(error, configuration.CultureInfo));
                }
            }
        }
    }
}
